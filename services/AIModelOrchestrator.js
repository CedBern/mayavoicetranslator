// Orchestrateur principal pour les services IA avanc√©s (Priorit√© 2)
import { CustomMayaModelTrainer } from './CustomMayaModelTrainer.js';
import { RealVectorDatabaseService } from './RealVectorDatabaseService.js';
import { AdvancedAudioCorpusService } from './AdvancedAudioCorpusService.js';
import { NativeTTSModelDeveloper } from './NativeTTSModelDeveloper.js';
import fs from 'fs/promises';
import path from 'path';

/**
 * Orchestrateur central pour coordonner tous les services IA avanc√©s
 * G√®re l'entra√Ænement, la synchronisation et l'optimisation des mod√®les
 */
class AIModelOrchestrator {
  constructor() {
    this.services = {
      modelTrainer: new CustomMayaModelTrainer(),
      vectorDB: new RealVectorDatabaseService(),
      audioCorpus: new AdvancedAudioCorpusService(),
      ttsModels: new NativeTTSModelDeveloper()
    };
    
    this.orchestrationConfig = {
      training_pipeline: {
        stages: [
          'corpus_preparation',
          'vector_indexing',
          'model_training',
          'tts_development',
          'evaluation',
          'deployment'
        ],
        parallel_processing: true,
        max_concurrent_jobs: 4,
        resource_monitoring: true
      },
      
      synchronization: {
        model_versions: new Map(),
        data_consistency_checks: true,
        cross_service_validation: true,
        backup_strategy: 'incremental'
      },
      
      optimization: {
        auto_tuning: true,
        performance_monitoring: true,
        resource_allocation: 'dynamic',
        scaling_strategy: 'horizontal'
      }
    };
    
    this.trainingPipeline = new Map();
    this.activeJobs = new Map();
    this.performanceMetrics = new Map();
    this.isInitialized = false;
  }

  /**
   * Initialise l'orchestrateur et tous les services IA
   */
  async initialize() {
    try {
      console.log('üöÄ Initialisation de l\'orchestrateur IA...');
      
      // Initialisation des services en parall√®le
      const initPromises = [
        this.services.modelTrainer.initialize(),
        this.services.vectorDB.initialize(),
        this.services.audioCorpus.initialize(),
        this.services.ttsModels.initialize()
      ];
      
      await Promise.all(initPromises);
      
      // Configuration de la synchronisation inter-services
      await this.setupServiceSynchronization();
      
      // V√©rification de la coh√©rence des donn√©es
      await this.performConsistencyCheck();
      
      this.isInitialized = true;
      console.log('‚úÖ Orchestrateur IA initialis√© avec succ√®s');
      
      return {
        success: true,
        services_ready: Object.keys(this.services).length,
        pipeline_stages: this.orchestrationConfig.training_pipeline.stages.length
      };
      
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'initialisation:', error);
      throw error;
    }
  }

  /**
   * Lance un pipeline d'entra√Ænement complet pour une langue
   */
  async startTrainingPipeline(language, options = {}) {
    if (!this.isInitialized) {
      await this.initialize();
    }
    
    const pipelineId = this.generatePipelineId(language);
    const config = {
      language,
      stages: options.stages || this.orchestrationConfig.training_pipeline.stages,
      parallel: options.parallel !== false,
      ...options
    };
    
    try {
      console.log(`üéØ D√©marrage du pipeline d'entra√Ænement pour ${language}`);
      
      this.trainingPipeline.set(pipelineId, {
        id: pipelineId,
        language,
        status: 'started',
        startTime: Date.now(),
        stages: new Map(),
        progress: 0
      });
      
      // √âtape 1: Pr√©paration du corpus
      await this.executeStage(pipelineId, 'corpus_preparation', async () => {
        return await this.services.audioCorpus.prepareCorpusForLanguage(language);
      });
      
      // √âtape 2: Indexation vectorielle
      await this.executeStage(pipelineId, 'vector_indexing', async () => {
        const corpusData = await this.services.audioCorpus.getLanguageCorpus(language);
        return await this.services.vectorDB.indexLanguageData(language, corpusData);
      });
      
      // √âtape 3: Entra√Ænement du mod√®le (parall√®le)
      if (config.parallel) {
        await Promise.all([
          this.executeStage(pipelineId, 'model_training', async () => {
            return await this.services.modelTrainer.trainLanguageModel(language);
          }),
          this.executeStage(pipelineId, 'tts_development', async () => {
            return await this.services.ttsModels.trainVoiceModel(language);
          })
        ]);
      } else {
        await this.executeStage(pipelineId, 'model_training', async () => {
          return await this.services.modelTrainer.trainLanguageModel(language);
        });
        
        await this.executeStage(pipelineId, 'tts_development', async () => {
          return await this.services.ttsModels.trainVoiceModel(language);
        });
      }
      
      // √âtape 4: √âvaluation
      await this.executeStage(pipelineId, 'evaluation', async () => {
        return await this.evaluateModels(language);
      });
      
      // √âtape 5: D√©ploiement
      await this.executeStage(pipelineId, 'deployment', async () => {
        return await this.deployModels(language);
      });
      
      const pipeline = this.trainingPipeline.get(pipelineId);
      pipeline.status = 'completed';
      pipeline.endTime = Date.now();
      pipeline.duration = pipeline.endTime - pipeline.startTime;
      
      console.log(`‚úÖ Pipeline d'entra√Ænement compl√©t√© pour ${language}`);
      return pipeline;
      
    } catch (error) {
      console.error(`‚ùå Erreur dans le pipeline pour ${language}:`, error);
      const pipeline = this.trainingPipeline.get(pipelineId);
      if (pipeline) {
        pipeline.status = 'failed';
        pipeline.error = error.message;
      }
      throw error;
    }
  }

  /**
   * Ex√©cute une √©tape du pipeline avec monitoring
   */
  async executeStage(pipelineId, stageName, stageFunction) {
    const pipeline = this.trainingPipeline.get(pipelineId);
    if (!pipeline) throw new Error(`Pipeline ${pipelineId} non trouv√©`);
    
    console.log(`üìã Ex√©cution de l'√©tape: ${stageName}`);
    
    const stageStart = Date.now();
    pipeline.stages.set(stageName, {
      status: 'running',
      startTime: stageStart,
      progress: 0
    });
    
    try {
      const result = await stageFunction();
      
      pipeline.stages.set(stageName, {
        status: 'completed',
        startTime: stageStart,
        endTime: Date.now(),
        duration: Date.now() - stageStart,
        result
      });
      
      // Mise √† jour du progr√®s global
      const completedStages = Array.from(pipeline.stages.values())
        .filter(stage => stage.status === 'completed').length;
      pipeline.progress = (completedStages / this.orchestrationConfig.training_pipeline.stages.length) * 100;
      
      console.log(`‚úÖ √âtape ${stageName} compl√©t√©e (${pipeline.progress.toFixed(1)}%)`);
      return result;
      
    } catch (error) {
      pipeline.stages.set(stageName, {
        status: 'failed',
        startTime: stageStart,
        endTime: Date.now(),
        error: error.message
      });
      
      console.error(`‚ùå √âchec de l'√©tape ${stageName}:`, error);
      throw error;
    }
  }

  /**
   * √âvalue la performance des mod√®les entra√Æn√©s
   */
  async evaluateModels(language) {
    const evaluation = {
      language,
      timestamp: Date.now(),
      metrics: {}
    };
    
    try {
      // √âvaluation du mod√®le de traduction
      const translationMetrics = await this.services.modelTrainer.evaluateModel(language);
      evaluation.metrics.translation = translationMetrics;
      
      // √âvaluation de la base vectorielle
      const vectorMetrics = await this.services.vectorDB.evaluateIndex(language);
      evaluation.metrics.vector_search = vectorMetrics;
      
      // √âvaluation de la reconnaissance vocale
      const asrMetrics = await this.services.audioCorpus.evaluateASRModel(language);
      evaluation.metrics.speech_recognition = asrMetrics;
      
      // √âvaluation TTS
      const ttsMetrics = await this.services.ttsModels.evaluateVoiceModel(language);
      evaluation.metrics.text_to_speech = ttsMetrics;
      
      // Score global
      evaluation.overall_score = this.calculateOverallScore(evaluation.metrics);
      
      this.performanceMetrics.set(language, evaluation);
      
      return evaluation;
      
    } catch (error) {
      console.error(`Erreur lors de l'√©valuation pour ${language}:`, error);
      throw error;
    }
  }

  /**
   * D√©ploie les mod√®les valid√©s
   */
  async deployModels(language) {
    try {
      const deployment = {
        language,
        timestamp: Date.now(),
        status: 'deploying',
        services: {}
      };
      
      // D√©ploiement du mod√®le de traduction
      deployment.services.translation = await this.services.modelTrainer.deployModel(language);
      
      // D√©ploiement de l'index vectoriel
      deployment.services.vector_db = await this.services.vectorDB.deployIndex(language);
      
      // D√©ploiement du mod√®le ASR
      deployment.services.asr = await this.services.audioCorpus.deployASRModel(language);
      
      // D√©ploiement du mod√®le TTS
      deployment.services.tts = await this.services.ttsModels.deployVoiceModel(language);
      
      deployment.status = 'deployed';
      deployment.endTime = Date.now();
      
      console.log(`üöÄ Mod√®les d√©ploy√©s avec succ√®s pour ${language}`);
      return deployment;
      
    } catch (error) {
      console.error(`Erreur lors du d√©ploiement pour ${language}:`, error);
      throw error;
    }
  }

  /**
   * Synchronise les donn√©es entre services
   */
  async setupServiceSynchronization() {
    // Configuration des callbacks de synchronisation
    this.services.audioCorpus.onCorpusUpdate = async (language, data) => {
      await this.services.vectorDB.updateLanguageIndex(language, data);
      await this.services.modelTrainer.updateTrainingData(language, data);
    };
    
    this.services.modelTrainer.onModelUpdate = async (language, model) => {
      await this.services.vectorDB.updateLanguageModel(language, model);
    };
    
    this.services.vectorDB.onIndexUpdate = async (language, index) => {
      await this.services.ttsModels.updateLanguageContext(language, index);
    };
  }

  /**
   * V√©rifie la coh√©rence des donn√©es entre services
   */
  async performConsistencyCheck() {
    const issues = [];
    
    // V√©rifier que les langues sont coh√©rentes entre services
    const languages = {
      trainer: await this.services.modelTrainer.getSupportedLanguages(),
      vector: await this.services.vectorDB.getIndexedLanguages(),
      audio: await this.services.audioCorpus.getAvailableLanguages(),
      tts: await this.services.ttsModels.getTrainedLanguages()
    };
    
    // Identifier les incoh√©rences
    const allLanguages = new Set([
      ...languages.trainer,
      ...languages.vector,
      ...languages.audio,
      ...languages.tts
    ]);
    
    for (const lang of allLanguages) {
      const availability = {
        trainer: languages.trainer.includes(lang),
        vector: languages.vector.includes(lang),
        audio: languages.audio.includes(lang),
        tts: languages.tts.includes(lang)
      };
      
      const availableCount = Object.values(availability).filter(Boolean).length;
      if (availableCount < 4) {
        issues.push({
          type: 'language_inconsistency',
          language: lang,
          availability,
          severity: availableCount < 2 ? 'high' : 'medium'
        });
      }
    }
    
    if (issues.length > 0) {
      console.warn('‚ö†Ô∏è Incoh√©rences d√©tect√©es:', issues);
    }
    
    return issues;
  }

  /**
   * Calcule le score global de performance
   */
  calculateOverallScore(metrics) {
    const weights = {
      translation: 0.3,
      vector_search: 0.2,
      speech_recognition: 0.25,
      text_to_speech: 0.25
    };
    
    let weightedSum = 0;
    let totalWeight = 0;
    
    for (const [metric, weight] of Object.entries(weights)) {
      if (metrics[metric] && metrics[metric].score !== undefined) {
        weightedSum += metrics[metric].score * weight;
        totalWeight += weight;
      }
    }
    
    return totalWeight > 0 ? weightedSum / totalWeight : 0;
  }

  /**
   * G√©n√®re un ID unique pour le pipeline
   */
  generatePipelineId(language) {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `${language}_pipeline_${timestamp}_${random}`;
  }

  /**
   * Obtient le statut de tous les pipelines actifs
   */
  getActivePipelines() {
    return Array.from(this.trainingPipeline.values())
      .filter(pipeline => ['started', 'running'].includes(pipeline.status));
  }

  /**
   * Obtient les m√©triques de performance
   */
  getPerformanceMetrics() {
    return Object.fromEntries(this.performanceMetrics);
  }

  /**
   * Nettoie les ressources et arr√™te tous les processus
   */
  async shutdown() {
    console.log('üõë Arr√™t de l\'orchestrateur IA...');
    
    // Arr√™ter tous les services
    const shutdownPromises = [
      this.services.modelTrainer.shutdown(),
      this.services.vectorDB.shutdown(),
      this.services.audioCorpus.shutdown(),
      this.services.ttsModels.shutdown()
    ];
    
    await Promise.allSettled(shutdownPromises);
    
    this.trainingPipeline.clear();
    this.activeJobs.clear();
    this.performanceMetrics.clear();
    this.isInitialized = false;
    
    console.log('‚úÖ Orchestrateur IA arr√™t√©');
  }
}

export { AIModelOrchestrator };
