/* tslint:disable */
/* eslint-disable */
/**
 * Maya Voice Translator - Validation Dashboard API
 * API for the collaborative validation dashboard for the Maya Voice Translator project. This API manages tasks, corrections, users, and administrative functions for validating linguistic data (transcriptions, translations, dictionary entries).
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: contact@mayavoicetranslator.app
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Correction
 */
export interface Correction {
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'taskId': string;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'submittedBy': string;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'status': CorrectionStatusEnum;
    /**
     * The corrected data
     * @type {object}
     * @memberof Correction
     */
    'data': object;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'reviewedBy'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'reviewedAt'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Correction
     */
    'feedback'?: string | null;
}

export const CorrectionStatusEnum = {
    Pending: 'pending',
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type CorrectionStatusEnum = typeof CorrectionStatusEnum[keyof typeof CorrectionStatusEnum];

/**
 * Data submitted by a user for a correction.
 * @export
 * @interface CorrectionSubmission
 */
export interface CorrectionSubmission {
    /**
     * The actual corrected data, structure depends on task type.
     * @type {object}
     * @memberof CorrectionSubmission
     */
    'data': object;
}
/**
 * 
 * @export
 * @interface DictionaryTaskData
 */
export interface DictionaryTaskData {
    /**
     * 
     * @type {LexicalEntry}
     * @memberof DictionaryTaskData
     */
    'entry': LexicalEntry;
}
/**
 * 
 * @export
 * @interface LexicalEntry
 */
export interface LexicalEntry {
    /**
     * 
     * @type {string}
     * @memberof LexicalEntry
     */
    'headword'?: string;
    /**
     * 
     * @type {string}
     * @memberof LexicalEntry
     */
    'partOfSpeech'?: string;
    /**
     * 
     * @type {Array<LexicalEntryDefinitionsInner>}
     * @memberof LexicalEntry
     */
    'definitions'?: Array<LexicalEntryDefinitionsInner>;
    /**
     * 
     * @type {Array<LexicalEntryPronunciationsInner>}
     * @memberof LexicalEntry
     */
    'pronunciations'?: Array<LexicalEntryPronunciationsInner>;
}
/**
 * 
 * @export
 * @interface LexicalEntryDefinitionsInner
 */
export interface LexicalEntryDefinitionsInner {
    /**
     * 
     * @type {string}
     * @memberof LexicalEntryDefinitionsInner
     */
    'text'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof LexicalEntryDefinitionsInner
     */
    'examples'?: Array<string>;
}
/**
 * 
 * @export
 * @interface LexicalEntryPronunciationsInner
 */
export interface LexicalEntryPronunciationsInner {
    /**
     * 
     * @type {string}
     * @memberof LexicalEntryPronunciationsInner
     */
    'notation'?: string;
    /**
     * 
     * @type {string}
     * @memberof LexicalEntryPronunciationsInner
     */
    'value'?: string;
    /**
     * 
     * @type {string}
     * @memberof LexicalEntryPronunciationsInner
     */
    'audioUrl'?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface ReviewCorrectionRequest
 */
export interface ReviewCorrectionRequest {
    /**
     * 
     * @type {string}
     * @memberof ReviewCorrectionRequest
     */
    'status'?: ReviewCorrectionRequestStatusEnum;
    /**
     * Optional feedback for the contributor
     * @type {string}
     * @memberof ReviewCorrectionRequest
     */
    'feedback'?: string;
}

export const ReviewCorrectionRequestStatusEnum = {
    Approved: 'approved',
    Rejected: 'rejected'
} as const;

export type ReviewCorrectionRequestStatusEnum = typeof ReviewCorrectionRequestStatusEnum[keyof typeof ReviewCorrectionRequestStatusEnum];

/**
 * 
 * @export
 * @interface Task
 */
export interface Task {
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'type': TaskTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'status': TaskStatusEnum;
    /**
     * 
     * @type {TaskData}
     * @memberof Task
     */
    'data': TaskData;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'assignedTo'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'createdBy': string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'createdAt'?: string;
    /**
     * 
     * @type {string}
     * @memberof Task
     */
    'updatedAt'?: string;
}

export const TaskTypeEnum = {
    Transcription: 'transcription',
    Translation: 'translation',
    Dictionary: 'dictionary'
} as const;

export type TaskTypeEnum = typeof TaskTypeEnum[keyof typeof TaskTypeEnum];
export const TaskStatusEnum = {
    Pending: 'pending',
    InProgress: 'in_progress',
    Completed: 'completed',
    Rejected: 'rejected'
} as const;

export type TaskStatusEnum = typeof TaskStatusEnum[keyof typeof TaskStatusEnum];

/**
 * @type TaskData
 * The source data for the task (e.g., audio URL, text snippet)
 * @export
 */
export type TaskData = DictionaryTaskData | TranscriptionTaskData | TranslationTaskData;

/**
 * 
 * @export
 * @interface TranscriptionTaskData
 */
export interface TranscriptionTaskData {
    /**
     * 
     * @type {string}
     * @memberof TranscriptionTaskData
     */
    'audioUrl': string;
    /**
     * A machine-generated transcript to start from
     * @type {string}
     * @memberof TranscriptionTaskData
     */
    'existingTranscript'?: string;
}
/**
 * 
 * @export
 * @interface TranslationTaskData
 */
export interface TranslationTaskData {
    /**
     * 
     * @type {string}
     * @memberof TranslationTaskData
     */
    'sourceLanguage': string;
    /**
     * 
     * @type {string}
     * @memberof TranslationTaskData
     */
    'targetLanguage': string;
    /**
     * 
     * @type {string}
     * @memberof TranslationTaskData
     */
    'text': string;
}
/**
 * 
 * @export
 * @interface UpdateTaskStatusRequest
 */
export interface UpdateTaskStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateTaskStatusRequest
     */
    'status'?: UpdateTaskStatusRequestStatusEnum;
    /**
     * User ID to assign the task to (Admin only)
     * @type {string}
     * @memberof UpdateTaskStatusRequest
     */
    'assignedTo'?: string;
}

export const UpdateTaskStatusRequestStatusEnum = {
    InProgress: 'in_progress',
    Pending: 'pending'
} as const;

export type UpdateTaskStatusRequestStatusEnum = typeof UpdateTaskStatusRequestStatusEnum[keyof typeof UpdateTaskStatusRequestStatusEnum];

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'roles': Array<UserRolesEnum>;
}

export const UserRolesEnum = {
    Contributor: 'contributor',
    Validator: 'validator',
    Admin: 'admin'
} as const;

export type UserRolesEnum = typeof UserRolesEnum[keyof typeof UserRolesEnum];


/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Allows an admin to create a new task.
         * @summary Create a new validation task
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask: async (task: Task, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'task' is not null or undefined
            assertParamExists('createTask', 'task', task)
            const localVarPath = `/admin/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(task, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can approve or reject a submitted correction.
         * @summary Review a correction
         * @param {string} correctionId 
         * @param {ReviewCorrectionRequest} reviewCorrectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewCorrection: async (correctionId: string, reviewCorrectionRequest: ReviewCorrectionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'correctionId' is not null or undefined
            assertParamExists('reviewCorrection', 'correctionId', correctionId)
            // verify required parameter 'reviewCorrectionRequest' is not null or undefined
            assertParamExists('reviewCorrection', 'reviewCorrectionRequest', reviewCorrectionRequest)
            const localVarPath = `/corrections/{correctionId}/review`
                .replace(`{${"correctionId"}}`, encodeURIComponent(String(correctionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reviewCorrectionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Allows an admin to create a new task.
         * @summary Create a new validation task
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTask(task: Task, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTask(task, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can approve or reject a submitted correction.
         * @summary Review a correction
         * @param {string} correctionId 
         * @param {ReviewCorrectionRequest} reviewCorrectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reviewCorrection(correctionId: string, reviewCorrectionRequest: ReviewCorrectionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Correction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reviewCorrection(correctionId, reviewCorrectionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.reviewCorrection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Allows an admin to create a new task.
         * @summary Create a new validation task
         * @param {Task} task 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(task: Task, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.createTask(task, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can approve or reject a submitted correction.
         * @summary Review a correction
         * @param {string} correctionId 
         * @param {ReviewCorrectionRequest} reviewCorrectionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reviewCorrection(correctionId: string, reviewCorrectionRequest: ReviewCorrectionRequest, options?: RawAxiosRequestConfig): AxiosPromise<Correction> {
            return localVarFp.reviewCorrection(correctionId, reviewCorrectionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Allows an admin to create a new task.
     * @summary Create a new validation task
     * @param {Task} task 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createTask(task: Task, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createTask(task, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can approve or reject a submitted correction.
     * @summary Review a correction
     * @param {string} correctionId 
     * @param {ReviewCorrectionRequest} reviewCorrectionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public reviewCorrection(correctionId: string, reviewCorrectionRequest: ReviewCorrectionRequest, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).reviewCorrection(correctionId, reviewCorrectionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CorrectionsApi - axios parameter creator
 * @export
 */
export const CorrectionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches all submitted corrections for a specific task.
         * @summary Get all corrections for a task
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrectionsForTask: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getCorrectionsForTask', 'taskId', taskId)
            const localVarPath = `/tasks/{taskId}/corrections`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a new correction for a task. The task must be assigned to the user. The submitted data structure depends on the task type.
         * @summary Submit a correction for a task
         * @param {string} taskId 
         * @param {CorrectionSubmission} correctionSubmission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCorrection: async (taskId: string, correctionSubmission: CorrectionSubmission, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('submitCorrection', 'taskId', taskId)
            // verify required parameter 'correctionSubmission' is not null or undefined
            assertParamExists('submitCorrection', 'correctionSubmission', correctionSubmission)
            const localVarPath = `/tasks/{taskId}/corrections`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(correctionSubmission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CorrectionsApi - functional programming interface
 * @export
 */
export const CorrectionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CorrectionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches all submitted corrections for a specific task.
         * @summary Get all corrections for a task
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCorrectionsForTask(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Correction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCorrectionsForTask(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrectionsApi.getCorrectionsForTask']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submits a new correction for a task. The task must be assigned to the user. The submitted data structure depends on the task type.
         * @summary Submit a correction for a task
         * @param {string} taskId 
         * @param {CorrectionSubmission} correctionSubmission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitCorrection(taskId: string, correctionSubmission: CorrectionSubmission, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Correction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitCorrection(taskId, correctionSubmission, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CorrectionsApi.submitCorrection']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CorrectionsApi - factory interface
 * @export
 */
export const CorrectionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CorrectionsApiFp(configuration)
    return {
        /**
         * Fetches all submitted corrections for a specific task.
         * @summary Get all corrections for a task
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCorrectionsForTask(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Correction>> {
            return localVarFp.getCorrectionsForTask(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Submits a new correction for a task. The task must be assigned to the user. The submitted data structure depends on the task type.
         * @summary Submit a correction for a task
         * @param {string} taskId 
         * @param {CorrectionSubmission} correctionSubmission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitCorrection(taskId: string, correctionSubmission: CorrectionSubmission, options?: RawAxiosRequestConfig): AxiosPromise<Correction> {
            return localVarFp.submitCorrection(taskId, correctionSubmission, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CorrectionsApi - object-oriented interface
 * @export
 * @class CorrectionsApi
 * @extends {BaseAPI}
 */
export class CorrectionsApi extends BaseAPI {
    /**
     * Fetches all submitted corrections for a specific task.
     * @summary Get all corrections for a task
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrectionsApi
     */
    public getCorrectionsForTask(taskId: string, options?: RawAxiosRequestConfig) {
        return CorrectionsApiFp(this.configuration).getCorrectionsForTask(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submits a new correction for a task. The task must be assigned to the user. The submitted data structure depends on the task type.
     * @summary Submit a correction for a task
     * @param {string} taskId 
     * @param {CorrectionSubmission} correctionSubmission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CorrectionsApi
     */
    public submitCorrection(taskId: string, correctionSubmission: CorrectionSubmission, options?: RawAxiosRequestConfig) {
        return CorrectionsApiFp(this.configuration).submitCorrection(taskId, correctionSubmission, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetches details for a single task.
         * @summary Get a specific task by ID
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById: async (taskId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getTaskById', 'taskId', taskId)
            const localVarPath = `/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of tasks available for the authenticated user. Can be filtered by status, type, and assigned user. Validators can see tasks assigned to them. Admins can see all tasks.
         * @summary Get a list of available validation tasks
         * @param {GetTasksStatusEnum} [status] Filter tasks by status
         * @param {GetTasksTypeEnum} [type] Filter tasks by type
         * @param {string} [assignedTo] Filter tasks by assigned user ID (Admin only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (status?: GetTasksStatusEnum, type?: GetTasksTypeEnum, assignedTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (assignedTo !== undefined) {
                localVarQueryParameter['assignedTo'] = assignedTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Allows a user to claim a pending task or release a task they are working on. Admins can also reassign tasks.
         * @summary Update a task\'s status (claim/unclaim)
         * @param {string} taskId 
         * @param {UpdateTaskStatusRequest} updateTaskStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskStatus: async (taskId: string, updateTaskStatusRequest: UpdateTaskStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('updateTaskStatus', 'taskId', taskId)
            // verify required parameter 'updateTaskStatusRequest' is not null or undefined
            assertParamExists('updateTaskStatus', 'updateTaskStatusRequest', updateTaskStatusRequest)
            const localVarPath = `/tasks/{taskId}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateTaskStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TasksApiAxiosParamCreator(configuration)
    return {
        /**
         * Fetches details for a single task.
         * @summary Get a specific task by ID
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskById(taskId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskById(taskId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getTaskById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a list of tasks available for the authenticated user. Can be filtered by status, type, and assigned user. Validators can see tasks assigned to them. Admins can see all tasks.
         * @summary Get a list of available validation tasks
         * @param {GetTasksStatusEnum} [status] Filter tasks by status
         * @param {GetTasksTypeEnum} [type] Filter tasks by type
         * @param {string} [assignedTo] Filter tasks by assigned user ID (Admin only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(status?: GetTasksStatusEnum, type?: GetTasksTypeEnum, assignedTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Task>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(status, type, assignedTo, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.getTasks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Allows a user to claim a pending task or release a task they are working on. Admins can also reassign tasks.
         * @summary Update a task\'s status (claim/unclaim)
         * @param {string} taskId 
         * @param {UpdateTaskStatusRequest} updateTaskStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaskStatus(taskId: string, updateTaskStatusRequest: UpdateTaskStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Task>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaskStatus(taskId, updateTaskStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TasksApi.updateTaskStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TasksApiFp(configuration)
    return {
        /**
         * Fetches details for a single task.
         * @summary Get a specific task by ID
         * @param {string} taskId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskById(taskId: string, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.getTaskById(taskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of tasks available for the authenticated user. Can be filtered by status, type, and assigned user. Validators can see tasks assigned to them. Admins can see all tasks.
         * @summary Get a list of available validation tasks
         * @param {GetTasksStatusEnum} [status] Filter tasks by status
         * @param {GetTasksTypeEnum} [type] Filter tasks by type
         * @param {string} [assignedTo] Filter tasks by assigned user ID (Admin only)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(status?: GetTasksStatusEnum, type?: GetTasksTypeEnum, assignedTo?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<Task>> {
            return localVarFp.getTasks(status, type, assignedTo, options).then((request) => request(axios, basePath));
        },
        /**
         * Allows a user to claim a pending task or release a task they are working on. Admins can also reassign tasks.
         * @summary Update a task\'s status (claim/unclaim)
         * @param {string} taskId 
         * @param {UpdateTaskStatusRequest} updateTaskStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaskStatus(taskId: string, updateTaskStatusRequest: UpdateTaskStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<Task> {
            return localVarFp.updateTaskStatus(taskId, updateTaskStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
    /**
     * Fetches details for a single task.
     * @summary Get a specific task by ID
     * @param {string} taskId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTaskById(taskId: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTaskById(taskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a list of tasks available for the authenticated user. Can be filtered by status, type, and assigned user. Validators can see tasks assigned to them. Admins can see all tasks.
     * @summary Get a list of available validation tasks
     * @param {GetTasksStatusEnum} [status] Filter tasks by status
     * @param {GetTasksTypeEnum} [type] Filter tasks by type
     * @param {string} [assignedTo] Filter tasks by assigned user ID (Admin only)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public getTasks(status?: GetTasksStatusEnum, type?: GetTasksTypeEnum, assignedTo?: string, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).getTasks(status, type, assignedTo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Allows a user to claim a pending task or release a task they are working on. Admins can also reassign tasks.
     * @summary Update a task\'s status (claim/unclaim)
     * @param {string} taskId 
     * @param {UpdateTaskStatusRequest} updateTaskStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TasksApi
     */
    public updateTaskStatus(taskId: string, updateTaskStatusRequest: UpdateTaskStatusRequest, options?: RawAxiosRequestConfig) {
        return TasksApiFp(this.configuration).updateTaskStatus(taskId, updateTaskStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetTasksStatusEnum = {
    Pending: 'pending',
    InProgress: 'in_progress',
    Completed: 'completed',
    Rejected: 'rejected'
} as const;
export type GetTasksStatusEnum = typeof GetTasksStatusEnum[keyof typeof GetTasksStatusEnum];
/**
 * @export
 */
export const GetTasksTypeEnum = {
    Transcription: 'transcription',
    Translation: 'translation',
    Dictionary: 'dictionary'
} as const;
export type GetTasksTypeEnum = typeof GetTasksTypeEnum[keyof typeof GetTasksTypeEnum];


